/* JavaToGraphviz.css

Righteo here's the default CSS then.

When we're generating the GV diagram, we create a completely separate DOM just for the purpose of styling the diagram.
Because I'm using jsoup to do the CSS selectors, it's a HTML DOM.
 
That DOM looks like this

<html>
  <body>
    <!-- CSS properties are converted to graphviz attributes by applying the CSS rules, and then extracting the calculated styles.
      In this DOM,
      'id' is used for the node name, so we can refer to it as #id in the CSS rules
      'label' is special HTML attribute for the 'label' graphviz attribute; use [label="xxxx"] in CSS rules
      'class' contains classes created by the AST ( 'if', 'expression' ) + some others created by the DAG ( 'break', 'continue' edges )
        will make a list of those somewhere.
        
      'inEdgeIds' contains IDs of in edges
      'inNodeIds' contains IDs of the nodes connected to those edges; use [inEdges~="abc"] to select a node with a particular inEdge
      'outEdgeIds' contains IDs of out edges
      'outNodeIds' contains IDs of the nodes connected to those edges
    -->
    <graph>
        
        <!-- the calculated CSS properties for graphNode gets applied to the default graphviz node attributes -->
        <graphNode style="shape: rect;"></graphNode>
        <!-- same for graphEdge -->
        <graphEdge style="shape: rect;"></graphEdge>
        
	    <subgraph>
	        <!-- the calculated CSS properties for a node gets applied to that specific node in the graphviz diagram -->
		    <node id="id" label="label" style="shape: rect;"></node> 
		    
		    <!-- same for edges -->
		    <edge id="id" label="label" style="shape: rect;"></node>
		</subgraph>
    </graph>		    
  </body>
</body>
*/
/* sketchviz defaults
   the properties in these CSS rules are graphviz attribute names, not CSS property names.
   there's also a handful of internal properties which are used during the diagram generation process; those are prefixed with "gv-"
 */
graph {
	fontname: "Handlee";
	bgcolor: transparent;
}
/* the styles on graphNode and graphEdge are applied at the graph level, 
   but styles on node and edge are (repeatedly) applied at the node and edges 
*/   
graphNode {
    fontname: "Handlee";
    shape : rect; 
}
graphEdge {
    fontname: "Handlee"
}

/* ok let's have some label formats as well */
/* node { gv-labelFormat : "${nodeType}"; } */

node {
	gv-idFormat: "s_${lineNumber}";
	/* gv-labelFormat: "${lineNumber}: ${nodeType} lkn: ${lastKeepNodeId}"; */
	gv-labelFormat: "${lineNumber}: ${nodeType}"; 
}
node.if {
	gv-idFormat: "if_${lineNumber}";
    gv-wordwrap: 20;
    shape : diamond; 
}
node.comment {
    gv-idFormat: "c_${lineNumber}";
}
node.method.end {
    gv-idFormat: "m_${lineNumber}";
    gv-labelFormat: "return";
}

node.methodDeclaration { gv-newSubgraph: true; }

/* through the magic of multiple CSS passes, the gv-newSubgraph rules above will construct a subgraph
   element which can also be styled in CSS. This only happens once.
*/
node.methodDeclaration > subgraph {
  /* subgraph ids must being with the text "cluster_" for graphviz to draw it as a subgraph */
  gv-idFormat : "cluster_m_${lineNumber}";
  gv-labelFormat : "method ${methodName}";
  pencolor : white; 
  labeljust : "l"; 
  ranksep : 0.5;
}



/* edge styles */

edge.break { color: red; gv-labelFormat: "break ${breakLabel}"; }
edge.continue { color: red; gv-labelFormat: "continue ${continueLabel}"; }
edge.return { color: blue; gv-labelFormat: "return"; }
edge.throw { color: purple; gv-labelFormat: "throw"; }

edge.back { style: dashed; }
edge.back.for { gv-labelFormat: "for"; }
edge.back.enhancedFor { gv-labelFormat: "for"; }
edge.back.while { gv-labelFormat: "while"; }
edge.back.do { gv-labelFormat: "do"; }






edge.if.true { gv-labelFormat: "Y"; }
edge.if.false { gv-labelFormat: "N"; }

edge.while.true { gv-labelFormat: "Y"; }
edge.while.false { gv-labelFormat: "N"; }

edge.do.start { } /* into repeating block */

edge.case { gv-labelFormat: "case"; }
edge.case.default { gv-labelFormat: "default"; }
edge.switch.fallthrough { } /* fall through from case block to next case */
edge.switch.false { } /* no case conditions match, and no default present */




