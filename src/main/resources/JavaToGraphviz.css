/* JavaToGraphviz.css

Righteo here's the default CSS then.

When we're generating the GV diagram, we create a completely separate DOM just for the purpose of styling the diagram.
Because I'm using jsoup to do the CSS selectors, it's a HTML DOM.
 
That DOM looks like this

<html>
  <body>
    <!-- CSS properties are converted to graphviz attributes by applying the CSS rules, and then extracting the calculated styles.
      In this DOM,
      'id' is used for the node name, so we can refer to it as #id in the CSS rules
      'label' is special HTML attribute for the 'label' graphviz attribute; use [label="xxxx"] in CSS rules
      'class' contains classes created by the AST ( 'if', 'expression' ) + some others created by the DAG ( 'break', 'continue' edges )
        will make a list of those somewhere.
        
      'inEdgeIds' contains IDs of in edges
      'inNodeIds' contains IDs of the nodes connected to those edges; use [inEdges~="abc"] to select a node with a particular inEdge
      'outEdgeIds' contains IDs of out edges
      'outNodeIds' contains IDs of the nodes connected to those edges
    -->
    <graph>
        
        <!-- the calculated CSS properties for graphNode gets applied to the default graphviz node attributes -->
        <graphNode style="shape: rect;"></graphNode>
        <!-- same for graphEdge -->
        <graphEdge style="shape: rect;"></graphEdge>
        
	    <subgraph>
	        <!-- the calculated CSS properties for a node gets applied to that specific node in the graphviz diagram -->
		    <node id="id" label="label" style="shape: rect;"></node> 
		    
		    <!-- same for edges -->
		    <edge id="id" label="label" style="shape: rect;"></node>
		</subgraph>
    </graph>		    
  </body>
</body>
*/
/* sketchviz defaults
   the properties in these CSS rules are graphviz attribute names, not CSS property names.
   there's also a handful of internal properties which are used during the diagram generation process; those are prefixed with "gv-"
 */
graph {
	fontname: "Handlee";
	bgcolor: transparent;
	gv-idFormat: "G";
    gv-labelFormat: unset;
}
/* the styles on graphNode and graphEdge are applied at the graph level, 
   but styles on node and edge are (repeatedly) applied at the node and edges 
*/   
graphNode {
    fontname: "Handlee";
    shape : rect; 
}
graphEdge {
    fontname: "Handlee"
}
subgraph {
  pencolor : black; 
  labeljust : "l";

  /* the ranksep here is an attempt to remove whitespace in the subgraph. 
     turns out this attribute is disregarded if there are any edge labels in the subgraph. which is a bit annoying. 
     xlabels don't add extra ranking whitespace, but the labels look a bit crap. */ 
  ranksep : 0.5;
}


/* ok let's have some label formats as well */
/* node { gv-labelFormat : "${nodeType}"; } */

node {
	gv-idFormat: "s_${lineNumber}";
	/* gv-labelFormat: "${lineNumber}: ${nodeType} lkn: ${lastKeepNodeId}"; */
	gv-labelFormat: "${lineNumber}: ${nodeType}"; 
}
node.if {
	gv-idFormat: "if_${lineNumber}";
    gv-wordwrap: 20;
    shape : diamond; 
}
node.comment {
    gv-idFormat: "c_${lineNumber}";
}
node.method.end {
    gv-idFormat: "m_${lineNumber}";
    gv-labelFormat: "return";
}

/** create a user-defined subgraph element *above* this node, then move this node and all nodes to gv-endSubgraph into that subgraph */
node.beginSubgraph { gv-beginOuterSubgraph: true; } 
node.endSubgraph { gv-endOuterSubgraph: true; }

/* hmm. subgraph:has(node.beginSubgraph) doesn't match here, but I think it should */
subgraph:has(node) { gv-idFormat : "cluster_uds_${lineNumber}"; gv-labelFormat : ""; }

node.methodDeclaration { gv-newSubgraph: true; } /* create a subgraph element *under* this node, then move child nodes into that subgraph */

/* through the magic of multiple CSS passes, the gv-newSubgraph rule above will construct a subgraph
   element which can also be styled in CSS. This only happens once.
*/
node.methodDeclaration > subgraph {
  /* subgraph ids must being with the text "cluster_" for graphviz to draw it as a subgraph */
  gv-idFormat : "cluster_m_${lineNumber}";
  gv-labelFormat : "method ${methodName}";
  pencolor : white;
}

/* in retrospect I reckon the methodDeclaration node should be *inside* the subgraph, which
would make the CSS rule something like
  subgraph:has(> .methodDeclaration) { ... }
instead, assuming jsoup's selector impl supports that.
maybe it should be a gv-newOuterSubgraph: true
or something 
*/


/*
node.try { gv-newSubgraph: true; }
node.try > subgraph {
  gv-idFormat : "cluster_t_${lineNumber}";
  gv-labelFormat : "try";
  pencolor : black; 
  labeljust : "l"; 
  ranksep : 0.5;
}
*/

/* these subgraphs are created by the code, not by CSS. Actually maybe I could do this in CSS. */

node.tryResource { gv-newSubgraph: true; } 
node.tryResource > subgraph {
  /* subgraph ids must being with the text "cluster_" for graphviz to draw it as a subgraph */
  gv-idFormat : "cluster_t_resource_${lineNumber}";
  gv-labelFormat : "resource";
  pencolor : white;
}


node.tryBody { gv-newSubgraph: true; } 
node.tryBody > subgraph {
  /* subgraph ids must being with the text "cluster_" for graphviz to draw it as a subgraph */
  gv-idFormat : "cluster_t_body_${lineNumber}";
  gv-labelFormat : "body";
}

node.catchClause { gv-newSubgraph: true; } 
node.catchClause > subgraph {
  /* subgraph ids must being with the text "cluster_" for graphviz to draw it as a subgraph */
  gv-idFormat : "cluster_t_catch_${lineNumber}";
  gv-labelFormat : "catch ${exceptionSpec}";
}

node.finally { gv-newSubgraph: true; } 
node.finally > subgraph {
  /* subgraph ids must being with the text "cluster_" for graphviz to draw it as a subgraph */
  gv-idFormat : "cluster_t_finally_${lineNumber}";
  gv-labelFormat : "finally";
}

node.synchronized { gv-newSubgraph: true; } 
node.synchronized > subgraph {
  /* subgraph ids must being with the text "cluster_" for graphviz to draw it as a subgraph */
  gv-idFormat : "cluster_sync_${lineNumber}";
  gv-labelFormat : "synchronized";
}




node.lambda { gv-newSubgraph: true; } /* when I get round to those */

/* edge styles */

edge.break { color: red; gv-labelFormat: "break ${breakLabel}"; }
edge.continue { color: red; gv-labelFormat: "continue ${continueLabel}"; }
edge.return { color: blue; gv-labelFormat: "return"; }

/* 'gv-xlabelFormat' here as labelling the throws really throws out the cluster layout. */ 
edge.throw { color: maroon;  gv-xlabelFormat: "throw"; } /* go the broncos */

edge.back { style: dashed; }
edge.back.for { gv-labelFormat: "for"; }
edge.back.enhancedFor { gv-labelFormat: "for"; }
edge.back.while { gv-labelFormat: "while"; }
edge.back.do { gv-labelFormat: "do"; }


/** @TODO  */
edge.if.true { gv-labelFormat: "Y"; }
edge.if.false { gv-labelFormat: "N"; }

edge.while.true { gv-labelFormat: "Y"; }
edge.while.false { gv-labelFormat: "N"; }

edge.do.start { } /* into repeating block */

edge.case { gv-labelFormat: "case"; }
edge.case.default { gv-labelFormat: "default"; }
edge.switch.fallthrough { } /* fall through from case block to next case */
edge.switch.false { } /* no case conditions match, and no default present */

/** If edges are in a subcluster, use xlabel rather than label otherwise graphviz double-spaces and triple-spaces the nodes */

subgraph subgraph edge.break { gv-labelFormat: unset; gv-xlabelFormat: "break ${breakLabel}"; }
subgraph subgraph edge.continue { gv-labelFormat: unset; gv-xlabelFormat: "continue ${continueLabel}"; }
subgraph subgraph edge.return { gv-labelFormat: unset; gv-xlabelFormat: "return"; }
subgraph subgraph edge.back.for { gv-labelFormat: unset;  gv-xlabelFormat: "for"; }
subgraph subgraph edge.back.enhancedFor { gv-labelFormat: unset; gv-xlabelFormat: "for"; }
subgraph subgraph edge.back.while { gv-labelFormat: unset; gv-xlabelFormat: "while"; }
subgraph subgraph edge.back.do { gv-labelFormat: unset; gv-xlabelFormat: "do"; }
subgraph subgraph edge.if.true { gv-labelFormat: unset; gv-xlabelFormat: "Y"; }
subgraph subgraph edge.if.false { gv-labelFormat: unset; gv-xlabelFormat: "N"; }
subgraph subgraph edge.while.true { gv-labelFormat: unset; gv-xlabelFormat: "Y"; }
subgraph subgraph edge.while.false { gv-labelFormat: unset; gv-xlabelFormat: "N"; }
subgraph subgraph edge.case { gv-labelFormat: unset; gv-xlabelFormat: "case"; }
subgraph subgraph edge.case.default { gv-labelFormat: unset; gv-xlabelFormat: "default"; }






